# 1. 函数
函数是组织好的，可重复使用的，用来实现单一或相关关联功能的代码段。函数能提高应用的模块性和代码的重复利用率。

## 1.1. 函数基础
### 1.1.1. 定义一个函数
在定义函数的过程中，需要注意以下几点：
- 函数代码块以`def`关键词开头，一个空格之后接函数标识符名称和圆括号`()`，再接个冒号`:`
- 任何传入的参数必须放在圆括号中间
- 函数第一行语句后可以选择性地使用文档字符串以用于存放函数说明
- 函数内容可以以冒号起始，并且缩进
- 使用return结束函数，默认返回None
- return语句依然在函数体内部，不能回退缩进。直到函数的所有代码写完，才回退缩进，表示函数体结束

基本语法：
```python
def functionname( parameters ):
   "函数_文档字符串"
   function_suite
   return [expression]
```

### 1.1.2. 函数调用
定义一个函数只给了函数一个名称，指定了函数里包含的参数，和代码块结构。    
这个函数的基本结构完成以后，可以通过另一个函数调用执行，也可以直接从Python提示符执行。如下：
```python
# 定义函数
def printme( str ):
   "打印任何传入的字符串"
   print str
   return
 
# 调用函数
printme("我要调用用户自定义函数!")
printme("再次调用同一函数")
```

### 1.1.3. 参数传递
函数通常都有参数，用于将外部的实际数据传入函数内部进行处理。但是，在处理不同数据类型的参数时，会有不同的情况发生。这一切都是因为以下两点。
- Python的函数参数传递的是实际对象的内存地址。
- Python的数据类型分可变数据类型和不可变数据类型。

在 python 中，类型属于对象，变量是没有类型的：
```python
a=[1,2,3]
 
a="Runoob"
```

以上代码中，[1,2,3] 是 List 类型，"Runoob" 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是 List 类型对象，也可以指向 String 类型对象。

#### 1.1.3.1. 可更改(mutable)与不可更改(immutable)对象
在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。
- 不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。
- 可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。

python 函数的参数传递：
- 不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。
- 可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响

python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。

### 1.1.4. return 语句
return语句[表达式]退出函数，选择性地向调用方返回一个表达式。不带参数值的return语句返回None。

### 1.1.5. 变量作用域
一个程序的所有的变量并不是在哪个位置都可以访问的。访问权限决定于这个变量是在哪里赋值的。    
变量的作用域决定了在哪一部分程序你可以访问哪个特定的变量名称。两种最基本的变量作用域如下：
- 全局变量
- 局部变量

#### 1.1.5.1. 全局变量和局部变量
定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。    
局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。

```python
total = 0 # 这是一个全局变量
# 可写函数说明
def sum( arg1, arg2 ):
   #返回2个参数的和."
   total = arg1 + arg2 # total在这里是局部变量.
   print "函数内是局部变量 : ", total
   return total
 
#调用sum函数
sum( 10, 20 )
print "函数外是全局变量 : ", total
```

### 1.1.6. 参数的传递
函数通常都有参数，用于将外部的实际数据传入函数内部进行处理。但是，在处理不同数据类型的参数时，会有不同的情况发生。这一切都是因为以下两点。
- Python的函数参数传递的是实际对象的内存地址。
- Python的数据类型分可变数据类型和不可变数据类型。

在 python 中，类型属于对象，变量是没有类型的：
```python
a=[1,2,3]
 
a="Runoob"
```

以上代码中，[1,2,3] 是 List 类型，"Runoob" 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是 List 类型对象，也可以指向 String 类型对象。

## 1.2. 参数类型
```python
x, y, z = 1, 2, 3

def add(a, b, c):

    return a+b+c

add(x, y, x)        # 使用变量，传递参数
add(4, 5, 6)        # 直接传递值也是可以的。
```

a，b，c叫做形式参数，简称形参。而x，y，z和4，5，6叫做实际参数，简称实参，也就是实际要传递的值。而我们通常讨论的参数，指的都是形参。

### 1.2.1. 位置参数
位置参数也叫必传参数、顺序参数，是最重要的，也是必须在调用函数时明确提供的参数，位置参数必须按先后顺序一一对应，个数不多不少的传递。


### 1.2.2. 默认参数
```python
def power(x, n = 2):
    return x**n

ret1 = power(10)   # 使用默认的参数值n=2
ret2 = power(10, 4)  # 将4传给n，实际计算10**4的值
```

在函数定义时，如果给某个参数提供一个默认值，这个参数就变成了默认参数，不再是位置参数了。在调用函数的时候，我们可以给默认参数传递一个自定义的值，也可以使用默认值。

还需注意以下几点：
- 默认参数必须在位置参数后面
- 使用参数名传递参数
- 默认参数尽量指向不变的对象
- 使用不可变的数据类型作为默认值

### 1.2.3. 动态参数
- 动态参数就是传入的参数的个数是动态的，可以是1个、2个到任意个，还可以是0个。
- python的动态参数有两种，分别是`*args`和`**kwargs`，这里面的关键是一个和两个星号的区别，而不是`args`和`kwargs`在名字上的区别，实际上你可以使用`*any`或`**whatever`的方式。但就如self一样，默认大家都使用`*args`和`**kwargs`。
- 动态参数必须放在所有的位置参数和默认参数后面

#### 1.2.3.1. *args
一个星号表示接收任意个参数。调用时，会将实际参数打包成一个元组传入形式参数。如果参数是个列表，会将整个列表当作一个参数传入。

```python
def func(*args):
    for arg in args:
        print(arg)

li = [1, 2, 3]
func(*li)
```

#### 1.2.3.2. **kwargs
两个星号表示接受键值对的动态参数，数量任意。调用的时候会将实际参数打包成字典。

```python
def func(**kwargs):
    for kwg in kwargs:
        print(kwg, kwargs[kwg])
        print(type(kwg))

func(k1='v1', k2=[0, 1, 2])
```

#### 1.2.3.3. 万能参数
当`*args`和`**kwargs`组合起来使用，理论上能接受任何形式和任意数量的参数，在很多代码中我们都能见到这种定义方式。需要注意的是，`*args`必须出现在`**kwargs`之前。

```python
def func(*args, **kwargs):

    for arg in args:
        print(arg)

    for kwg in kwargs:
        print(kwg, kwargs[kwg])


lis = [1, 2, 3]
dic = {
    'k1': 'v1',
    'k2': 'v2'
}

func(*lis, **dic)
```

#### 1.2.3.4. 关键字参数
关键字参数前面需要一个特殊分隔符`*`和位置参数及默认参数分隔开来，`*`后面的参数被视为关键字参数。在函数调用时，关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错。不同于默认参数，关键字参数必须传递，但是关键字参数也可以有缺省值，这时就可以不传递了，从而简化调用。

## 1.3. 变量作用域
- 作用域指的是变量的有效范围。变量并不是在哪个位置都可以访问的，访问权限取决于这个变量是在哪里赋值的，也就是在哪个作用域内的。
- 通常，函数内部的变量无法被函数外部访问，但内部可以访问；类内部的变量无法被外部访问，但类的内部可以。通俗来讲，就是内部代码可以访问外部变量，而外部代码通常无法访问内部变量。
- python函数的作用域取决于其函数代码块在整体代码中的位置，而不是调用时机的位置。

python的作用域一共有四层，分别是：
- L（Local）局部作用域
- E（Enclosing）闭包函数外的函数中
- G（Global）全局作用域
- B（Built-in）内建作用域

### 1.3.1. 全局变量和局部变量
- 定义在函数内部的变量拥有一个局部作用域，被叫做局部变量，定义在函数外的拥有全局作用域的变量，被称为全局变量。（类、模块等同理）
- 所谓的局部变量是相对的。局部变量也有可能是更小范围内的变量的外部变量。
- 局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。

```python
a = 1               # 全局变量

def func():
    b = 2           # 局部变量
    print(a)        # 可访问全局变量a,无法访问它内部的c

    def inner():
        c = 3       # 更局部的变量
        print(a)    # 可以访问全局变量a
        print(b)    # b对于inner函数来说，就是外部变量
        print(c)
```

### 1.3.2. global和nonlocal关键字
- global：指定当前变量使用外部的全局变量
- nonlocal：可以修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量

## 1.4. range()函数
range()函数具体用法：
- 提供一个数字参数，直接便利数字
- 可以指定遍历的区间
- 可以指定步长，就像切片一样
- 更多的时候是结合range和len函数，遍历一个序列的索引

## 1.5. 递归函数
递归最核心思想：每一次递归，整体问题都要比原来减小，并且递归到一定层次时，要直接给出结果。

每一个递归程序都遵循相同的基本步骤：
- 初始化算法。递归程序通常需要一个开始时使用的种子值（seed value）。可以向函数传递参数，或者提供一个入口函数，这个函数是非递归的，但可以为递归计算设置种子值。
- 检查要处理的当前值是否已经与基线条件相匹配（base case）。如果匹配，则进行处理并返回值。
- 使用更小的或更简单的子问题（或多个子问题）来重新定义答案。
- 对子问题运行算法。
- 将结果合并入答案的表达式。
- 返回结果。

## 1.6. 匿名函数
python中使用`lambda`关键字来创建匿名函数。即不再使用`def`语句这样标准的形式定义一个函数。

主要特点:
- lambda只是一个表达式，而不是一个代码块，函数体比def简单很多
- 仅仅能在lambda表达式中封装有限的逻辑
- lambfa函数拥有自己的命名空间

lambda关键字主要形式通常是：`lambda 参数：表达式`

`lambda x: x * x`，关键字lambda表示匿名函数，冒号前面的x表示函数参数，x*x是执行代码。

匿名函数只能有一个表达式，不用也不能写return语句，表达式的结果就是其返回值。 匿名函数没有函数名字，不必担心函数名冲突，节省字义空间。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数；也可以把匿名函数作为别的函数的返回值返回。

## 1.7. 推导式
- Python 推导式是一种独特的数据处理方式，可以从一个数据序列构建另一个新的数据序列的结构体。
- Python 推导式是一种强大且简洁的语法，适用于生成列表、字典、集合和生成器。
- 在使用推导式时，需要注意可读性，尽量保持表达式简洁，以免影响代码的可读性和可维护性。

python支持各种数据结构的推导式：
- 列表推导式
- 字典推导式
- 集合推导式
- 元组推导式

### 1.7.1. 列表推导式
格式为：

```python
[表达式 for 变量 in 列表] 
[out_exp_res for out_exp in input_list]

或者 

[表达式 for 变量 in 列表 if 条件]
[out_exp_res for out_exp in input_list if condition]
```

### 1.7.2. 字典推导式
格式为：

```python
{ key_expr: value_expr for value in collection }

或

{ key_expr: value_expr for value in collection if condition }
```

### 1.7.3. 集合推导式
格式为：

```python
{ expression for item in Sequence }
或
{ expression for item in Sequence if conditional }
```

### 1.7.4. 元组推导式
格式为：

```python
(expression for item in Sequence )
或
(expression for item in Sequence if conditional )
```

## 1.8. 迭代器
- 迭代：通过for循环遍历对象的每一个元素的过程
- python中可以遍历任何可迭代的对象
- list/tuple/string/dict/set/bytes都是可以迭代的数据类型
- 迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问结束后。
- 迭代器只能往后遍历不能回溯
- 迭代器通常要实现基本方法：`iter()`和`next()`


迭代器(Iterator)和可迭代(Iterable)的区别：
- 凡是可作用于for循环的对象都是可迭代类型；
- 凡是可作用于next()函数的对象都是迭代器类型；
- list、dict、str等是可迭代的但不是迭代器，因为next()函数无法调用它们。可以通过iter()函数将它们转换成迭代器。
- Python的for循环本质上就是通过不断调用next()函数实现的。

## 1.9. 生成器
- 在python中，使用`yield`返回的函数会变成一个生成器（generator）。
- 在调用生成器的过程中，每次遇到yield时函数会暂停并保存当前所有的运行信息，返回yield的值，并在下一次执行next()方法时从当前位置继续执行。

```python
def countdown(n):
    while n > 0:
        yield n
        n -= 1


# 创建生成器对象
generator = countdown(5)

# 通过迭代生成器获取值
print(next(generator))  # 输出: 5
print(next(generator))  # 输出: 4
print(next(generator))  # 输出: 3

# 使用 for 循环迭代生成器
for value in generator:
    print(value)  # 输出: 2 1
```

## 1.10. 装饰器
- 装饰器（decorators）允许动态修改函数或类的行为。
- 装饰器是一种函数，它接受一个函数作为参数，并返回一个新的函数或修改原来的函数。
- 装饰器的语法使用`@decorator_name`来应用在函数或方法上。
- python还提供了一些内置的装饰器，比如`@staticmethod`和`@classmethod`，用于定义静态方法和类方法。
- 装饰器的语法是：被装饰的函数的名字会被当作参数传递给装饰函数。装饰函数执行它自己内部的代码后，会将它的返回值赋值给被装饰的函数。

装饰器应用场景：
- 日志记录：可用于记录函数的调用信息、参数和返回值
- 性能分析：来测量函数的执行时间
- 权限控制：可用于限制对某些函数的访问权限
- 缓存：用于实现函数结果的缓存以提高性能


```python
def outer(func):
    def inner():
        print("认证成功！")
        result = func()
        print("日志添加成功")
        return result
    return inner

@outer
def f1():
    print("业务部门1数据接口......")

@outer
def f2():
    print("业务部门2数据接口......")
@outer
def f3():
    print("业务部门3数据接口......")

@outer
def f100():
    print("业务部门100数据接口......")

#各部门分别调用
f1()
f2()
f3()
f100()
```