# 1. 面向对象
## 1.1. 概念及术语
- 类(Class): 用来描述具有相同属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。其中的对象被称作类的实例。
- 实例：也称对象。通过类定义的初始化方法，赋予具体的值，成为一个"有血有肉的实体"。
- 实例化：创建类的实例的过程或操作。
- 实例变量：定义在实例中的变量，只作用于当前实例。
- 类变量：类变量是所有实例公有的变量。类变量定义在类中，但在方法体之外。
- 数据成员：类变量、实例变量、方法、类方法、静态方法和属性等的统称。
- 方法：类中定义的函数。
- 静态方法：不需要实例化就可以由类执行的方法
- 类方法：类方法是将类本身作为对象进行操作的方法。
- 方法重写：如果从父类继承的方法不能满足子类的需求，可以对父类的方法进行改写，这个过程也称override。
- 封装：将内部实现包裹起来，对外透明，提供api接口进行调用的机制
- 继承：即一个派生类（derived class）继承父类（base class）的变量和方法。
- 多态：根据对象类型的不同以不同的方式进行处理。

## 1.2. 类和实例
python使用class关键字来定义类，基本结构如下：

```python
class 类名(父类列表):
    pass
```

- 类名通常采用驼峰式命名方式。
- Python采用多继承机制，一个类可以同时继承多个父类（也叫基类、超类），继承的基类有先后顺序，写在类名后的圆括号里。
- 继承的父类列表可以为空，此时的圆括号可以省略。

### 1.2.1. 实例变量和类变量
#### 1.2.1.1. 实例变量
- 实例变量是指实例本身拥有的变量。
- 每个实例的变量在内存中都不一样。

#### 1.2.1.2. 类变量
- 定义在类中，方法之外的变量称为类变量。
- 类变量是所有实例公有的变量，每一个实例都可以访问、修改类变量。
- 可以通过类名或者实例名加圆点的方式访问类变量：`类名.类变量`

### 1.2.2. 类的方法
- python的类中包含实例方法、静态方法和类方法三种方法。
- 实例方法、静态方法和类方法无论是在代码编排中还是内存中都归属于类，区别在于传入的参数和调用的方式不同。
- 在类的内部，使用`def`关键字来定义一个方法

#### 1.2.2.1. 实例方法
- 类的实例方法由实例调用，至少包含一个self参数，且为第一个参数。
- 执行实例方法时，会自动将调用该方法的实例赋值给self。
- self代表的是类的实例，而非类本身
- self不是关键字

#### 1.2.2.2. 静态方法
- 静态方法由类调用，无默认参数。
- 将实例方法参数中的self去掉，然后在方法定义上方加上`@staticmethod`。
- 静态方法属于类，和实例无关。
- 建议只使用`类名.静态方法`的调用方式。

#### 1.2.2.3. 类方法
- 类方法由类调用，采用`@classmethod`装饰，至少传入一个cls（代指类本身，类似self）。
- 执行类方法时，自动将调用该方法的类赋值给cls。
- 建议只使用`类名.类方法`的调用方式。

## 1.3. 封装、继承和多态
>面向对象编程的三大重要特征：封装、继承和多态。

### 1.3.1. 封装
>封装是指将数据与具体操作的实现代码放在某个对象内部，使这些代码的实现细节不被外界发现，外界只能通过接口使用该对象，而不能通过任何形式修改对象内部实现，正是由于封装机制，程序在使用某一对象时不需要关心该对象的数据结构细节及实现操作的方法。使用封装能隐藏对象实现细节，使代码更易维护，同时因为不能直接调用、修改对象内部的私有信息，在一定程度上保证了系统安全性。类通过将函数和变量封装在内部，实现了比函数更高一级的封装。


### 1.3.2. 继承
Python支持多父类的继承机制，所以需要注意圆括号中基类的顺序，若是基类中有相同的方法名，并且在子类使用时未指定，Python会从左至右搜索基类中是否包含该方法。一旦查找到则直接调用，后面不再继续查找。

python3 与 python2 继承机制不同之处：
- 子类在调用某个方法或变量的时候，首先在自己内部查找，如果没有找到，则开始根据继承机制在父类里查找。
- 根据父类定义中的顺序，以深度优先的方式逐一查找父类。

### 1.3.3. 多态
在 Python3 中，多态是指同一个方法或者操作可以在不同的对象上产生不同的行为或结果。意味着一个函数可以接受不同类型的参数，并且可以表现出不同的行为。

在使用多态的时候，需要注意以下几点：
- 定义基类时需要考虑到所有子类的共性，并设计出一些通用的方法，而这些方法需要在所有子类中都有意义。
- 子类需要重写父类的方法，并且该方法需要与父类的方法具有相同的名称、参数和返回类型。否则，在使用多态时可能会出现错误。
- 在使用多态的函数或方法中，需要确保传递给它们的参数是正确的类型。如果传递了错误的类型，那么程序可能会在运行时发生异常。
- 在编写多态的代码时，需要注意代码的可读性和可维护性。过于复杂的继承关系和方法重载可能会使代码变得难以理解和维护。

## 1.4. 成员保护和访问限制
### 1.4.1. 私有成员
在python中，如果要让内部成员不被外部访问，可以在成员的名字前加上两个下划线`__`，这个成员就变成了一个私有成员（private）。

```python
class People:
    title = "人类"

    def __init__(self, name, age):
        self.__name = name
        self.__age = age

    def print_age(self):
        print('%s: %s' % (self.__name, self.__age))

obj = People("jack", 18)
obj.__name

------------------------------
Traceback (most recent call last):
  File "F:/Python/pycharm/201705/1.py", line 68, in <module>
    obj.__name
AttributeError: 'People' object has no attribute '__name'
```

### 1.4.2. 类的成员与下划线
- `_name、_name_、_name__`:建议性的私有成员，不要在外部访问。
- `__name、 __name_`:强制的私有成员，但是你依然可以蛮横地在外部危险访问。
- `__name__`:特殊成员，与私有性质无关，例如__doc__。
- `name_、name__`:没有任何特殊性，普通的标识符，但最好不要这么起名。

## 1.5. @property装饰器
`@property装饰器`可以把类的方法伪装成属性调用的方式。即本来是`Foo.func()`的调用方法，变成`Foo.func`的方式。

代码如下：

```python
class People:

    def __init__(self, name, age):
        self.__name = name
        self.__age = age

    @property
    def age(self):
        return self.__age

    @age.setter
    def age(self, age):
        if isinstance(age, int):
            self.__age = age
        else:
            raise ValueError

    @age.deleter
    def age(self):
        print("删除年龄数据！")


obj = People("jack", 18)
print(obj.age)
obj.age = 19
print("obj.age:  ", obj.age)
del obj.age

```

### 1.5.1. property()函数
Python内置的builtins模块中的property()函数，提供了第二种设置类属性的手段。

代码如下：

```python
class People:

    def __init__(self, name, age):
        self.__name = name
        self.__age = age

    def get_age(self):
        return self.__age

    def set_age(self, age):
        if isinstance(age, int):
            self.__age = age
        else:
            raise ValueError

    def del_age(self):
        print("删除年龄数据！")

    # 核心在这句
    age = property(get_age, set_age, del_age, "年龄")


obj = People("jack", 18)
print(obj.age)
obj.age = 19
print("obj.age:  ", obj.age)
del obj.age
```

property()函数语法：

```python
property(fget=None, fset=None, fdel=None, doc=None)
```

property()函数的参数：
- 第一个参数是方法名，调用`实例.属性`时自动执行的方法
- 第二个参数是方法名，调用`实例.属性=XXX`时自动执行的方法
- 第三个参数是方法名，调用`del 实例.属性`时自动执行的方法
- 第四个参数是字符串，调用`实例.属性.__doc__`时的描述信息

## 1.6. 特殊成员和魔法方法
Python中有大量类似__doc__这种以双下划线开头和结尾的特殊成员及“魔法方法”，它们有着非常重要的地位和作用，也是Python语言独具特色的语法之一！

如：

```python
__init__ :      构造函数，在生成对象时调用
__del__ :       析构函数，释放对象时使用
__repr__ :      打印，转换
__setitem__ :   按照索引赋值
__getitem__:    按照索引获取值
__len__:        获得长度
__cmp__:        比较运算
__call__:       调用
__add__:        加运算
__sub__:        减运算
__mul__:        乘运算
__div__:        除运算
__mod__:        求余运算
__pow__:        幂
```

参考：[特殊成员和魔法方法](https://liujiangblog.com/course/python/47)

## 1.7. reflect反射
